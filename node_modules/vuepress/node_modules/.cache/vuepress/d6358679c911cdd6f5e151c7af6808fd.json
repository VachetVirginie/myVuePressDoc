{"remainingRequest":"/Users/vivi./Dev/myVuePressDoc/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/vivi./Dev/myVuePressDoc/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/vivi./Dev/myVuePressDoc/docs/aws/lambdaarticle.md?vue&type=template&id=4955b186&","dependencies":[{"path":"/Users/vivi./Dev/myVuePressDoc/docs/aws/lambdaarticle.md","mtime":1631613175236},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/cache-loader/dist/cjs.js","mtime":1660115262090},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/cache-loader/dist/cjs.js","mtime":1660115262090},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/babel-loader/lib/index.js","mtime":1660115261629},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1660115262578},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/cache-loader/dist/cjs.js","mtime":1660115262090},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/vue-loader/lib/index.js","mtime":1660115262578},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1660115261540}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"lambda-article\"><a class=\"header-anchor\" href=\"#lambda-article\" aria-hidden=\"true\">#</a> lambda article</h1>\n<h2 id=\"le-cloud-computing-ou-«-systeme-infonuagique-»-en-quebecois-✨\"><a class=\"header-anchor\" href=\"#le-cloud-computing-ou-«-systeme-infonuagique-»-en-quebecois-✨\" aria-hidden=\"true\">#</a> Le cloud computing (ou « système infonuagique » en québécois ✨)</h2>\n<p>Aaaah, le cloud. Cela fait maintenant de nombreuses années qu'on en entend parler. A tel point que ce buzz word ne veut désormais plus dire grand chose.</p>\n<p>Pour comprendre rapidement ce qu'est le cloud, nous pouvons catégoriser les nombreux services cloud qui existent. Ce ne sont d'ailleurs pas les acronymes qui manquent pour définir ces catégories. Ainsi, on distingue habituellement ces 4 types de services :</p>\n<h3 id=\"iaas-infrastructure-as-a-service\"><a class=\"header-anchor\" href=\"#iaas-infrastructure-as-a-service\" aria-hidden=\"true\">#</a> IaaS (Infrastructure as a Service)</h3>\n<p>Avec ce type de service, le fournisseur met à disposition des machines virtuelles sur lesquelles vous avez la main pour installer l'OS de votre choix et faire tourner tous les logiciels que vous souhaitez.</p>\n<p>La plupart des hébergeurs fournissent ce genre de service : OVH avec sa gamme Public Cloud, Amazon avec EC2, Google et son Compute Engine, etc.</p>\n<p>L'avantage avec ces offres est que vous pouvez configurer votre instance comme bon vous semble. En contrepartie de cette flexibilité, il vous revient de configurer l'OS et vos services comme il faut : serveur HTTP, bases de données, applicatif, backups. C'est également à vous d'appliquer toutes les mises à jour des différents logiciels installés. De plus, avec ce type d'offre, par défaut, votre infrastructure ne s'adaptera pas automatiquement à la charge de trafic.</p>\n<p>Pour résumer, c'est à vous de tout configurer comme il faut, le fournisseur ne s'occupant que de la partie « hardware » (même si elle est virtualisée).</p>\n<h3 id=\"paas-platform-as-a-service\"><a class=\"header-anchor\" href=\"#paas-platform-as-a-service\" aria-hidden=\"true\">#</a> PaaS (Platform as a Service)</h3>\n<p>Avec ce type de service, toute la partie infrastructure, OS et outils est gérée par le fournisseur. Vous n'avez pas à gérer les mises à jours, configurer le serveur HTTP ou gérer les backups.</p>\n<p>En règle générale, vous aurez seulement besoin de définir comment fonctionne votre application et les « services » dont elle a besoin, comme par exemple :</p>\n<ul>\n<li>comment exécuter votre application (langage, web root, dépendances à installer, etc) ;</li>\n<li>la (ou les) base(s) de données utilisée(s) ;</li>\n<li>le taille du filesystem.</li>\n</ul>\n<p>Il ne vous reste plus qu'à envoyer votre code (souvent via un simple <code>git push</code>) et le code sera utilisable en production, dans le cloud, après quelques secondes/minutes. Vous l'aurez compris, l'intérêt de ce genre d'offre, c'est de se concentrer sur la partie applicative (votre code PHP donc) et de ne plus avoir à gérer la partie Ops.</p>\n<p>Parmis ceux qui fournissent ce genre de service, on peut citer notamment :</p>\n<ul>\n<li>Clever Cloud, que nous remercions au passage car ils sponsorisent l'hébergement de <a href=\"https://secret-santa.team\" target=\"_blank\" rel=\"noopener noreferrer\">Secret Santa<OutboundLink/></a> ;</li>\n<li>Heroku ;</li>\n<li>Symfony Cloud, spécialisé pour l'hébergement d'application Symfony ;</li>\n<li>Platform.sh ;</li>\n<li>Google App Engine.</li>\n</ul>\n<h3 id=\"faas-function-as-a-service\"><a class=\"header-anchor\" href=\"#faas-function-as-a-service\" aria-hidden=\"true\">#</a> FaaS (Function as a Service)</h3>\n<p>Ce type de cloud est assez similaire au PaaS dans la mesure où il permet également une approche « serverless » : la partie « matérielle », l'OS et les différents outils sont toujours gérés par le fournisseur.</p>\n<p>En revanche, là où Faas et PaaS se différencient, c'est sur la manière d'exécuter votre code. Alors que le PaaS fonctionne globalement comme une infrastructure classique -- un serveur HTTP répond à votre requête en appelant votre application -- il en est tout autrement pour une Fonction.</p>\n<p>En effet, avec les fonctions en tant que service, le processus qui exécute votre application n'a pas besoin de rester en vie quand il ne sert pas. Autrement dit, le fournisseur se charge de démarrer le « serveur » quand c'est nécessaire et de le couper quand il n'y a plus besoin. L'avantage ? Vous n'êtes facturés que pour les ressources réellement consommées (par exemple le temps d'exécution), contrairement à un serveur plus classique dont vous paierez le même montant tous les mois, qu'il soit beaucoup utilisé ou pas du tout. Le FaaS est donc un allié parfait dans beaucoup de cas d'utilisations qui ne nécessitent pas de frontend :</p>\n<ul>\n<li>application micro-service ;</li>\n<li>API ;</li>\n<li>IoT ;</li>\n<li>webhook ;</li>\n<li>traitement par batch ;</li>\n<li>worker (AMQP ou non).</li>\n</ul>\n<p>Autre avantage non négligeable : la plateforme se charge de démarrer autant de processus que nécessaire pour s'adapter à la charge de trafic actuelle, sans que vous n'ayez rien à faire.</p>\n<p>Parmis les plus célèbres fournisseurs de FaaS, on notera :</p>\n<ul>\n<li>AWS Lambda d'Amazon ;</li>\n<li>Microsoft et son Azure Functions ;</li>\n<li>Google avec Cloud Functions.</li>\n</ul>\n<h3 id=\"saas-software-as-a-service-et-xaas-everything-as-a-service\"><a class=\"header-anchor\" href=\"#saas-software-as-a-service-et-xaas-everything-as-a-service\" aria-hidden=\"true\">#</a> SaaS (Software as a Service) et XaaS (Everything as a Service)</h3>\n<p>Enfin, dans ces catégories, on retrouve plutôt des produits finaux qui sont mis à votre disposition directement, sans rien avoir à installer ou mettre à jour, rien à héberger et encore à moins à développer. Le Saas fournit la plupart du temps un logiciel utilisable en ligne, directement depuis un navigateur web. Le XaaS, quant à lui, est une catégorie un peu fourre-tout qui regroupe une quantité grandissante de sous-catégorie de service cloud :</p>\n<ul>\n<li>Data as a Service : base de données gérée par un fournisseur ;</li>\n<li>Storage as a Service : stockage de fichiers géré par un fournisseur ;</li>\n<li>Identity as a Service : identités numériques (annuaires, SSO, WebSSO) gérées par un fournisseur ;</li>\n<li>etc.</li>\n</ul>\n<p>Nous ne nous intéresserons pas plus longtemps à ces types de services puisqu'ils ne sont pas faits pour exécuter votre code.</p>\n<p>Maintenant que nous avons fait le tour des différentes catégories de cloud, c'est bien avec la catégorie Function as a Service que nous allons continuer cet article, et notamment avec l'offre AWS Lambda d'Amazon.</p>\n<h2 id=\"bref-parlons-lambda\"><a class=\"header-anchor\" href=\"#bref-parlons-lambda\" aria-hidden=\"true\">#</a> Bref, parlons lambda</h2>\n<p>L'offre AWS Lambda, disponible depuis 2014, est l'une des plateformes FaaS les plus connues pour faire tourner des fonctions dans le cloud. Mais au fait, c'est quoi une fonction ?</p>\n<h3 id=\"fonction-lambda\"><a class=\"header-anchor\" href=\"#fonction-lambda\" aria-hidden=\"true\">#</a> Fonction ? Lambda ?</h3>\n<p>Lorsque nous parlons de fonction dans le cloud, il s'agit de l'application qui sera exécutée pour répondre à un événement. On peut vraiment faire le parallèle avec une fonction que l'on trouverait dans notre code : c'est une brique qui va recevoir un événement en entrée et qui devra retourner une réponse en sortie.</p>\n<p>On utilise le terme de fonction plutôt que d'application car le but recherché est souvent d'avoir une tâche assez atomique. L'intérêt d'une fonction ne faisant qu'une seule chose est qu'elle soit plutôt légère et rapide à exécuter et qu'elle puisse être lancée en parallèle de manière optimale.</p>\n<p>Enfin, le terme lambda peut-être vu comme un synonyme de fonction bien qu'en général, il s'agisse en particulier du service de FaaS d'Amazon AWS.</p>\n<h3 id=\"bref\"><a class=\"header-anchor\" href=\"#bref\" aria-hidden=\"true\">#</a> Bref</h3>\n<p>Et si configurer son application pour l'exécuter sous forme de lambda était aussi simple qu'un <code>composer require</code> ? Ce n'est en tout cas pas loin d'être réalité, grâce au travail acharné de <a href=\"https://twitter.com/matthieunapoli\" target=\"_blank\" rel=\"noopener noreferrer\">Matthieu Napoli<OutboundLink/></a>. Depuis quelques années maintenant, il développe <a href=\"https://bref.sh/\" target=\"_blank\" rel=\"noopener noreferrer\">Bref<OutboundLink/></a>, un outil permettant d'executer assez simplement du code PHP en serverless dans des lambdas Amazon. Il a mis l'accent aussi bien sur la facilité d'utilisation Bref que sur la mise à disposition d'une documentation complète. Je ne peux d'ailleurs que vous conseiller de lire la <a href=\"https://bref.sh/docs/\" target=\"_blank\" rel=\"noopener noreferrer\">documentation qui explique ce qu'est Bref<OutboundLink/></a>. Il maintient même <a href=\"https://serverless-php.news/\" target=\"_blank\" rel=\"noopener noreferrer\">une newsletter<OutboundLink/></a> pour se tenir informé des dernières nouveautés dans le monde du serverless et de PHP.</p>\n<p>Pour résumer, Bref se présente à la fois comme un package Composer, un plugin pour le <a href=\"https://serverless.com/\" target=\"_blank\" rel=\"noopener noreferrer\">framework Serverless<OutboundLink/></a> (un outil permettant, entre autre, de déployer du code dans le cloud) et des environnements d'exécutions de PHP pour AWS Lambda.</p>\n<h3 id=\"runtimes-php\"><a class=\"header-anchor\" href=\"#runtimes-php\" aria-hidden=\"true\">#</a> Runtimes PHP</h3>\n<p>AWS Lambda est de plus en plus utilisé, y compris dans le monde PHP, alors même que la plateforme ne supporte pas nativement notre langage. Et pourtant, PHP est l'un des meilleurs langages pour faire du serverless. En effet, il a été pensé dès ses débuts pour fonctionner en « fire and forget », c'est à dire qu'entre chaque requête reçue, PHP est complètement réinitialisé et ne conserve aucune donnée. Et ce mode de fonctionnement est exactement similaire à celui d'une lambda.</p>\n<p>Et heureusement pour nous, Amazon fournit la possibilité d'utiliser des environnements custom, sans compromis sur la rapidité de démarrage ni lors de l'exécution de votre fonction. C'est pour cette raison que Bref fournit 3 runtimes PHP pour exécuter votre code.</p>\n<p>Le premier runtime, appelé simplement « fonction », est le plus simple. Il consiste à exécuter du code PHP sous la forme d'une fonction PHP recevant le payload de l'évènement en paramètre :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>&lt;?php\n\nuse Bref\\Context\\Context;\n\nrequire __DIR__ . &#39;/vendor/autoload.php&#39;;\n\nreturn function ($event, Context $context) {\n    return /* un contenu serializable en JSON */\n};\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Bref fournit un deuxième runtime, appelé lui « HTTP ». Son nom vous aura mis sur la piste, il permet de faire tourner une application HTTP comme si elle était dans une infrastructure classique. Cela signifie que votre lambda pourra tout à fait être une application Symfony ou Laravel ! Elle recevra les données sous forme d'une requête HTTP et devra retourner une réponse HTTP.</p>\n<p>Enfin, dernier runtime à disposition, celui nommé « console ». Il vous permettra d'invoquer des applications CLI basées sur Symfony, Silly ou Laravel Artisan. Par exemple, depuis votre projet en local, vous pourrez invoquer votre lambda grâce à Bref :</p>\n<p><code>vendor/bin/bref cli &lt;function-name&gt; -- &lt;command&gt;</code></p>\n<p><code>&lt;function-name&gt;</code> étant le nom de votre lambda et <code>&lt;command&gt;</code> la commande que votre application devra lancer.</p>\n<h3 id=\"world-wide\"><a class=\"header-anchor\" href=\"#world-wide\" aria-hidden=\"true\">#</a> World-wide</h3>\n<p>Pour ma part, j'ai eu l'occasion de manipuler des lambdas pour la première fois pour un outil de monitoring que nous avons développé en interne. Ce n'était pas tant la partie FaaS qui m'intéressait que la possibilité de faire exécuter des checks depuis différentes régions du monde.</p>\n<p>En effet, avec AWS Lambda, nous avons le choix de déployer notre code dans une <a href=\"https://docs.aws.amazon.com/fr_fr/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions\" target=\"_blank\" rel=\"noopener noreferrer\">vingtaine de régions<OutboundLink/></a>. Pratique dans mon cas pour s'assurer qu'un site fonctionne correctement partout dans le monde.</p>\n<h3 id=\"le-cout-un-sujet-complexe\"><a class=\"header-anchor\" href=\"#le-cout-un-sujet-complexe\" aria-hidden=\"true\">#</a> Le coût, un sujet complexe</h3>\n<p>Dernier point à aborder avant de rentrer dans la partie un peu plus technique, celui du coût. Comme nous l'avons vu dans le premier chapitre, la facturation qui se fait en fonction des ressources réellement consommées est l'un des avantages du serverless. Mais par définition, cela signifie que vous ne pouvez pas prévoir à l'avance combien va vous coûter votre fonction. Le montant variera principalement en fonction du nombre d'exécutions et de la durée d'exécution de chaque invocation.</p>\n<p>Mais cela coûte-t-il moins cher de faire de tourner du code dans une fonction que dans une infrastructure plus classique ? Il n'y a pas de réponse magique. Vous trouverez autant d'articles sur internet expliquant que les lambda ont permis à des personnes d'économiser beaucoup d'argent et avoir un système plus rapide, que des articles expliquant tout le contraire. <a href=\"https://aws.amazon.com/fr/lambda/pricing/\" target=\"_blank\" rel=\"noopener noreferrer\">Amazon fournit d'ailleurs une documentation et un estimateur<OutboundLink/></a> pour avoir une idée du montant que pourrait vous coûter votre fonction. Bon à savoir, Amazon fournit un plan gratuit qui inclut 1 million d'invocations gratuites par mois et 400 000 Go-secondes de temps de calcul par mois. Ce qui vous laisse donc pas mal de marge pour tester, le prix d'une Go-seconde étant le prix pour exécuter une fonction qui dure 1 seconde en lui fournissant 1 Go de mémoire.</p>\n<p>Pour avoir un ordre d'idée, sur mon application de monitoring, une cinquantaine d'urls sont surveillées, dont une quinzaine sont monitorées toutes les minutes avec des checks effectués dans 2 régions du monde (donc 2 lambdas) :</p>\n<p>60 min x 24 h x 30 j x 2 lambdas x 15 urls = 1 296 000 appels / mois</p>\n<p>Même si je suis encore sous les 400 000 Go-secondes, je dépasse donc légèrement du free tiers sur le nombre d'invocations. Cependant, la facture reste en dessous de... 10 centimes par mois. Rien d'insurmontable pour le moment donc 😛. N'hésitez pas à regarder <a href=\"https://cost-calculator.bref.sh/\" target=\"_blank\" rel=\"noopener noreferrer\">le simulateur que propose Bref<OutboundLink/></a> pour avoir un ordre d'idée sur le montant que pourrait vous coûter l'utilisation d'une lambda.</p>\n<p>De plus, Amazon propose un <a href=\"https://console.aws.amazon.com/billing/home#/budgets\" target=\"_blank\" rel=\"noopener noreferrer\">système de budget et d'alerte<OutboundLink/></a> pour vous prévenir quand vous atteignez un certain pourcentage de votre budget. Pratique pour éviter les surprises.</p>\n<p>Après toute cette théorie, il est maintenant temps d'être un peu plus concret. Prêt pour enfin voir un peu de code ?</p>\n<h2 id=\"cloudfinement\"><a class=\"header-anchor\" href=\"#cloudfinement\" aria-hidden=\"true\">#</a> Cloudfinement</h2>\n<p>Durant ce confinement dû à l'épidémie de COVID-19, les usages internet des particuliers ont nettement augmenté, notamment à cause de l'usage intensif des plateformes vidéo, telles que Amazon Prime et Netflix, ou des visios-conférences. Même si tout se passe globalement bien pour nos chers Fournisseurs d'Accès à Internet, il n'est pas rare de constater de grosses baisses de débit par moment, surtout chez ceux ne possédant pas la fibre. Je vous propose donc que nous développions une petite application nous permettant de vérifier qu'un site marche correctement ou non. En exécutant cette application dans une lambda, cela nous permettra de vérifier que le site fonctionne ou non depuis une autre connexion que la vôtre, confirmant ainsi si le problème se trouve seulement sur votre ligne ou si tout le monde le subit.</p>\n<h3 id=\"notre-application\"><a class=\"header-anchor\" href=\"#notre-application\" aria-hidden=\"true\">#</a> Notre application</h3>\n<p>Commençons par la partie la plus classique, à savoir la création de notre application :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>symfony new cloudfinement --full\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Notre code restera volontairement très simple, le but de cet exemple n'étant pas de s'étendre sur la partie applicative. Voici donc les 2 fichiers à rajouter, à savoir un controller et son template associé :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>&lt;?php\n\nnamespace App\\Controller;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpClient\\HttpClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\nclass DefaultController extends AbstractController\n{\n    /**\n     * @Route(&quot;/&quot;, name=&quot;home&quot;)\n     */\n    public function home(Request $request)\n    {\n        $url = null;\n        $error = false;\n        $message = null;\n\n        if ($url = $request-&gt;query-&gt;get(&#39;url&#39;)) {\n            $client = HttpClient::create();\n            try {\n                $response = $client-&gt;request(&#39;GET&#39;, $url, [\n                    &#39;max_duration&#39; =&gt; 1,\n                ]);\n\n                if (!$response-&gt;getContent()) {\n                    $error = true;\n                    $message = &#39;Did not receive any content&#39;;\n                } else {\n                    $error = false;\n                }\n            } catch (\\Throwable $e) {\n                $error = true;\n                $message = $e-&gt;getMessage();\n            }\n        }\n\n        return $this-&gt;render(&#39;home.html.twig&#39;, [\n            &#39;url&#39; =&gt; $url,\n            &#39;error&#39; =&gt; $error,\n            &#39;message&#39; =&gt; $message,\n        ]);\n    }\n}\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>{% extends &#39;base.html.twig&#39; %}\n\n{% block body %}\n   &lt;h1&gt;Cloudfinement&lt;/h1&gt;\n\n   &lt;p&gt;Check if a url is down / slow for everyone or just for you:&lt;/p&gt;\n\n   &lt;form method=&quot;get&quot;&gt;\n       &lt;label for=&quot;url&quot;&gt;\n           Url to check\n       &lt;/label&gt;\n       &lt;input id=&quot;url&quot; type=&quot;url&quot; name=&quot;url&quot; value=&quot;{{ url|default(&#39;https://&#39;)}}&quot;&gt;\n\n       &lt;button type=&quot;submit&quot;&gt;Vérifier&lt;/button&gt;\n   &lt;/form&gt;\n\n   {% if url %}\n       &lt;div style=&quot;margin-top: 20px; color: {{ error ? &#39;red&#39; : &#39;green&#39; }};&quot;&gt;\n           {% if error %}\n               &lt;h2&gt;Looks like you are not alone&lt;/h2&gt;\n\n               &lt;p&gt;\n                   {{ message }}\n               &lt;/p&gt;\n           {% else %}\n               &lt;h2&gt;Everything looks good from here&lt;/h2&gt;\n\n               &lt;p&gt;If you&#39;ve got some problem with this website, it may just be your connection&lt;/p&gt;\n           {% endif %}\n       &lt;/div&gt;\n   {% endif %}\n{% endblock %}\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Expliquons rapidement ce que fait ce code. Nous affichons un formulaire avec un champ permettant de saisir une URL. Une fois ce formulaire soumis, nous allons utiliser le client HTTP fourni dans Symfony pour appeler l'URL en question.</p>\n<p>Si l'URL cible répond en moins d'une seconde et avec un code HTTP valide (2XX ou 3XX), alors nous affichons que tout est ok :</p>\n<p>Sinon, on affiche le message d'erreur :</p>\n<h3 id=\"configurer-bref-aws-et-serverless\"><a class=\"header-anchor\" href=\"#configurer-bref-aws-et-serverless\" aria-hidden=\"true\">#</a> Configurer Bref, AWS et Serverless</h3>\n<p>Encore une fois, la documentation de Bref est assez complète et précise <a href=\"https://bref.sh/docs/installation.html\" target=\"_blank\" rel=\"noopener noreferrer\">toutes les étapes nécessaires<OutboundLink/></a>. Pour résumer, vous devez :</p>\n<ul>\n<li>\n<p>Créer un compte sur <a href=\"https://aws.amazon.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Amazon AWS<OutboundLink/></a> (vous devrez saisir une carte bleue, même si vous n'utilisez que le plan gratuit)</p>\n</li>\n<li>\n<p>Installer le framework Serverless (sur lequel se base Bref) : <code>npm install -g serverless</code></p>\n</li>\n<li>\n<p>Créer les clés d'accès à AWS <a href=\"https://bref.sh/docs/installation/aws-keys.html\" target=\"_blank\" rel=\"noopener noreferrer\">comme expliqué en image dans la documentation de Bref<OutboundLink/></a></p>\n</li>\n<li>\n<p>Configurer Serverless avec vos clés : <code>serverless config credentials --provider aws --key &lt;key&gt; --secret &lt;secret&gt;</code></p>\n</li>\n<li>\n<p>Installer Bref <code>composer require bref/bref</code></p>\n</li>\n<li>\n<p>Configurer Bref <code>vendor/bin/bref init</code></p>\n</li>\n</ul>\n<p>Dans cette commande interactive, il va falloir répondre aux questions posées. Dans notre cas, seul le type de fonction désirée nous est demandé. Cela permet à Bref de choisir le bon runtime à utiliser. Et comme nous sommes partis avec une application HTTP en Symfony, il nous faudra répondre « HTTP application ».</p>\n<p>2 fichiers ont été créés :</p>\n<ul>\n<li>serverless.yml</li>\n<li>index.php</li>\n</ul>\n<p>Symfony fournissant déjà un front controlleur (<code>public/index.php</code>), nous pouvons supprimer celui généré par Bref et modifier le handler dans la config <code>serverless.yml</code> :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code> functions:\n     api:\n-        handler: index.php\n+        handler: public/index.php\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>rm index.php\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Nous allons aussi modifier la région vers laquelle notre code sera envoyé. Parce que j'ai déjà des lambdas déployées sur mon compte pour 2 régions européennes, je choisis, pour cet exemple, d'utiliser la région AWS nommée <code>eu-west-2</code>, <a href=\"https://docs.aws.amazon.com/fr_fr/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions\" target=\"_blank\" rel=\"noopener noreferrer\">située à Londres<OutboundLink/></a>. Modifions encore notre fichier <code>serverless.yml</code> :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code> provider:\n     name: aws\n-    region: us-east-1\n+    region: eu-west-2\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"derniers-preparatifs-avant-le-lancement\"><a class=\"header-anchor\" href=\"#derniers-preparatifs-avant-le-lancement\" aria-hidden=\"true\">#</a> Derniers préparatifs avant le lancement</h3>\n<p>Au risque de me répéter, il ne faut pas hésiter à consulter toute la documentation de Bref. Il y a notamment <a href=\"https://bref.sh/docs/frameworks/symfony.html\" target=\"_blank\" rel=\"noopener noreferrer\">une page dédiée pour le déploiement d'application Symfony<OutboundLink/></a>.</p>\n<p>Une chose importante à expliquer pour comprendre cette étape, c'est la façon dont l'outil Serverless déploie une application. En effet, celui-ci va d'abord construire une archive à partir de votre application locale puis l'envoyer à AWS. Mais avant de construire cette archive, nous allons devoir préparer notre application locale pour ne pas envoyer de choses inutiles dans la lambda (cache et log Symfony, node_modules, tests, etc).</p>\n<p>Première chose à faire, nous allons supprimer les dépendances de dev. On en profite, au passage, pour optimiser l'autoloader généré par Composer :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>APP_ENV=prod composer install --prefer-dist --optimize-autoloader --no-dev\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Note : la variable <code>APP_ENV</code> est nécessaire pour que les commandes Symfony (notamment le <code>cache:clear</code>) soit executée en mode prod, sinon Symfony tournera en mode dev (cf votre fichier .env) et cela provoquera des erreurs à cause de dépendances manquantes.</p>\n<p>Ensuite, nous allons dire à Serverless d'ignorer notre dossier <code>var</code> (Bref ajoute déjà de quoi ignorer les dossiers <code>node_modules</code> et <code>tests</code>) :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code> package:\n     exclude:\n+        - &#39;.idea/**&#39;\n         - &#39;node_modules/**&#39;\n         - &#39;tests/**&#39;\n+        - &#39;var/**&#39;\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p><a href=\"https://bref.sh/docs/environment/serverless-yml.html#exclusions\" target=\"_blank\" rel=\"noopener noreferrer\">N'hésitez pas à exclure tout fichier<OutboundLink/></a> qui ne servirait pas en production, comme de la documentation ou le dossier de votre IDE par exemple.</p>\n<p>Nous allons également configurer les variables d'environnement nécessaires à notre application :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code> provider:\n     name: aws\n     region: eu-west-2\n     runtime: provided\n+    environment:\n+        # Symfony environment variables\n+        APP_ENV: prod\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Enfin, nous devons apporter une ultime modification à notre application Symfony. En effet, mise à part le dossier <code>/tmp</code>, le filesystem de notre lambda sera en lecture seule. Symfony ne pourra donc pas écrire dans son dossier <code>var</code>. Deux choix s'offrent alors à nous :</p>\n<ul>\n<li>soit déplacer les dossiers de log et de cache dans <code>/tmp</code> ;</li>\n<li>soit faire en sorte de pré-générer le cache à l'avance (avec la commande <code>bin/console cache:warmup</code>) et de configurer Symfony/Monolog pour envoyer les logs ailleurs.</li>\n</ul>\n<p>C'est la première solution que nous choisirons ici. Et pour ce faire, rien de plus simple. Il suffit de surcharger deux méthodes dans le Kernel :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>+    public function getLogDir()\n+    {\n+        // When on the lambda only /tmp is writeable\n+        if (getenv(&#39;LAMBDA_TASK_ROOT&#39;) !== false) {\n+            return &#39;/tmp/log/&#39;;\n+        }\n+\n+        return parent::getLogDir();\n+    }\n+\n+    public function getCacheDir()\n+    {\n+        // When on the lambda only /tmp is writeable\n+        if (getenv(&#39;LAMBDA_TASK_ROOT&#39;) !== false) {\n+            return &#39;/tmp/cache/&#39;.$this-&gt;environment;\n+        }\n+\n+        return parent::getCacheDir();\n+    }\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>C'est parti, nous ne sommes plus qu'à une commande de pouvoir utiliser notre lambda. 🙌🏻</p>\n<h3 id=\"direction-les-nuages\"><a class=\"header-anchor\" href=\"#direction-les-nuages\" aria-hidden=\"true\">#</a> Direction : les nuages</h3>\n<p>Comme promis, voici la dernière commande à exécuter :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>serverless deploy\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Et c'est tout !</p>\n<p>Serverless va se charger de packager votre application, l'envoyer dans l'infrastructure d'AWS et configurer votre lambda comme il faut. Pour vous simplifier la tâche, il vous affiche également, à la fin, les endpoints sur lesquels votre lambda sera accessible. Vous pouvez donc maintenant ouvrir le premier endpoint (celui sans proxy) dans votre navigateur et commencer à jouer avec votre application.</p>\n<p>Alors ? Heureux d'être enfin propriétaire de votre première fonction dans le cloud ?</p>\n<p>Si vous souhaitez comprendre un peu plus ce qu'il se passe lors du déploiement de votre lambda, n'hésitez pas à... <a href=\"https://bref.sh/docs/deploy.html#cloudformation-stacks\" target=\"_blank\" rel=\"noopener noreferrer\">consulter la documentation de bref<OutboundLink/></a> expliquant un peu plus en détails comment Serverless utilise différents services d'AWS pour uploader le package et configurer la lambda. D'ailleurs, vous constaterez un nouveau dossier nommé <code>.serverless</code> à la racine de votre projet. C'est dedans que le framework Serverless construit le package et stocke différents fichiers de configuration. Vous pourrez donc ajouter ce dossier dans votre .gitignore, son contenu étant recréé à chaque déploiement.</p>\n<p>Alors évidemment, déployer une telle application avec Symfony dans une lambda n'est probablement pas la solution la plus adaptée. On aurait tout aussi bien pu envoyer un unique script PHP. Mais cet exemple aura au moins eu le mérite de vous montrer comment configurer et déployer une application Symfony dans une lambda Amazon. Si votre application nécessite une base de données ou fournit des fichiers statiques via AWS S3, la lambda sera un peu plus complexe à mettre en place. Mais <a href=\"https://bref.sh/docs/environment/database.html\" target=\"_blank\" rel=\"noopener noreferrer\">encore une fois<OutboundLink/></a>, Matthieu Napoli a ajouté de <a href=\"https://bref.sh/docs/environment/custom-domains.html#custom-domains-for-static-files-on-s3\" target=\"_blank\" rel=\"noopener noreferrer\">nombreuses documentations<OutboundLink/></a> sur comment réaliser cela, donc vous ne devriez pas avoir de mauvaises surprises.</p>\n<h2 id=\"protips\"><a class=\"header-anchor\" href=\"#protips\" aria-hidden=\"true\">#</a> Protips</h2>\n<p>Avant de conclure cet article, je voudrais vous partager quelques astuces récoltées lors de mes propres expériences ou de mes lectures.</p>\n<h3 id=\"ajouter-une-lambda-dans-une-application-existante\"><a class=\"header-anchor\" href=\"#ajouter-une-lambda-dans-une-application-existante\" aria-hidden=\"true\">#</a> Ajouter une lambda dans une application existante</h3>\n<p>Si vous souhaitez ajouter une lambda pour certaines tâches à un projet existant, il est plus simple de faire une application à part dans son propre dossier. Vous pourrez y stocker le composer.json avec les outils dont vous avez besoin, notamment Bref, ainsi que le code à exécuter dans la lambda.</p>\n<p>Si votre fonction a besoin de code provenant de votre application, vous pourrez importer votre application en dépendance. Prenons cette arborescence en exemple :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>project/\n    application/\n        src/\n        composer.json\n    lambda/\n        index.php\n        composer.json\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Assurez-vous d'abord que le composer.json de votre application contient un nom de package, par exemple « nom-du-projet/application ». Ensuite, vous pouvez utiliser le système de <a href=\"https://getcomposer.org/doc/05-repositories.md#path\" target=\"_blank\" rel=\"noopener noreferrer\">repository local de composer<OutboundLink/></a> pour définir des dépendances dont le package se trouve en local. Dans le composer.json de votre lambda, rajoutez :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>{\n    &quot;type&quot;: &quot;project&quot;,\n    &quot;require&quot;: {\n        &quot;bref/bref&quot;: &quot;^0.5.0&quot;,\n        &quot;nom-du-projet/application&quot;: &quot;*@dev&quot;\n    },\n    &quot;repositories&quot;: [\n        {\n            &quot;type&quot;: &quot;path&quot;,\n            &quot;url&quot;: &quot;../application&quot;\n        }\n    ]\n}\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Après un <code>composer install</code>, vous pourrez profiter dans votre lambda du code déjà existant dans votre application. En revanche, pensez à bien exclure les fichiers de votre application qui seront inutiles pour votre lambda :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>package:\n    exclude:\n        - vendor/nom-du-projet/application/assets/**\n        - vendor/nom-du-projet/application/node_modules/**\n        - vendor/nom-du-projet/application/public/**\n        - vendor/nom-du-projet/application/tests/**\n        - vendor/nom-du-projet/application/var/**\n        - vendor/nom-du-projet/application/vendor/**\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"appeler-une-lambda-depuis-son-code-php\"><a class=\"header-anchor\" href=\"#appeler-une-lambda-depuis-son-code-php\" aria-hidden=\"true\">#</a> Appeler une lambda depuis son code PHP</h3>\n<p>Dans notre exemple, nous avons déployé une lambda de type « application HTTP ». Si le but de notre lambda était de réaliser un traitement particulier, nous aurions pu choisir un runtime de type « function » et l'appeler de manière programmatique. Cela se fait assez facilement en PHP avec le sdk officiel d'AWS :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>composer require aws/aws-sdk-php\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>    use Aws\\Lambda\\LambdaClient;\n\n    $lambdaClient = new LambdaClient([\n        &#39;version&#39; =&gt; &#39;latest&#39;,\n        &#39;region&#39; =&gt; $_SERVER[&#39;AWS_REGION],\n        &#39;credentials&#39; =&gt; [\n            &#39;key&#39; =&gt; $_SERVER[&#39;AWS_KEY&#39;],\n            &#39;secret&#39; =&gt; $_SERVER[&#39;AWS_SECRET_KEY&#39;],\n        ],\n    ]);\n    $awsResult = $lambdaClient-&gt;invoke([\n        &#39;FunctionName&#39; =&gt; $_SERVER[&#39;AWS_LAMBDA_FUNCTION_NAME&#39;],\n        &#39;InvocationType&#39; =&gt; &#39;RequestResponse&#39;,\n        &#39;LogType&#39; =&gt; &#39;None&#39;,\n        &#39;Payload&#39; =&gt; json_encode($payload),\n    ]);\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>La documentation de Bref présente quelques informations supplémentaires pour <a href=\"https://bref.sh/docs/runtimes/function.html#invocation\" target=\"_blank\" rel=\"noopener noreferrer\">invoquer vos fonctions<OutboundLink/></a>.</p>\n<h3 id=\"performance\"><a class=\"header-anchor\" href=\"#performance\" aria-hidden=\"true\">#</a> Performance</h3>\n<p>Redémarrer la lambda et PHP de zéro entre chaque requête n'est évidemment pas la manière la plus performante d'exécuter notre code. Le temps de boot des lambdas avec les runtimes de Bref tourne aux alentours de 250 ms en moyenne <a href=\"https://bref.sh/docs/environment/performances.html#optimizing-cold-starts\" target=\"_blank\" rel=\"noopener noreferrer\">d'après la documentation<OutboundLink/></a>. Ce démarrage à froid, ou « cold start » dans la langue de Shakespeare, peut-être optimisé voire supprimé :</p>\n<p>Diminuer le nombre de fichiers packagés (grâce à la directive <code>exclude</code>, comme expliqué dans l'exemple) permet d'améliorer la vitesse de boot de votre lambda.</p>\n<p>AWS attend plusieurs minutes d'inactivité (entre 10 et 60 minutes d'après ce que j'ai pu lire sur internet) avant de couper votre lambda. Vous pouvez donc éviter au maximum les cold starts en faisant en sorte de maintenir votre lambda réveillée (en la pinguant à intervalle régulier par exemple).</p>\n<h3 id=\"oublier-d-exclure-certains-fichiers\"><a class=\"header-anchor\" href=\"#oublier-d-exclure-certains-fichiers\" aria-hidden=\"true\">#</a> Oublier d'exclure certains fichiers</h3>\n<p>Si la taille du package est trop grande, le déploiement peut échouer avec le message suivant :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>An error occurred: ApiLambdaFunction - Unzipped size must be smaller than 146578616 bytes (Service: AWSLambdaInternal; Status Code: 400; Error Code: InvalidParameterValueException; Request ID: 6ccd1416-634a-400a-93e9-aea0237b70be).\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Cela arrive notamment si vous oubliez d'exclure des fichiers trop volumineux et souvent inutiles, comme du cache, une base de données sqlite, des fichiers CSV, etc. Faites le ménage et/ou ajoutez les chemins à exclure puis retentez le déploiement.</p>\n<h3 id=\"surveiller-le-cout\"><a class=\"header-anchor\" href=\"#surveiller-le-cout\" aria-hidden=\"true\">#</a> Surveiller le coût</h3>\n<p>Devoir enregistrer une carte bleue lors de la création du compte AWS alors que l'on a aucune idée du montant que cela nous coûtera à la fin du mois, et ce malgré le plan gratuit d'Amazon, est la partie qui m'a le plus inquiété quand j'ai commencé à jouer avec les lambdas.</p>\n<p>La première chose que j'ai faite a été de définir un budget dans mon compte AWS. J'ai enregistré un montant de 1$ pour être alerté par email dès que le budget est atteint. Et je me suis aussi ajouté un reminder dans Slack tous les lundis pour aller vérifier manuellement, dans la console AWS, que le montant de ma facture ne s'était pas envolé. Je vous l'ai dit que j'étais pas rassuré ? 😅</p>\n<p>Au final, AWS fournit par défaut des alertes quand les quotas du plan gratuit atteignent 85%, donc vous devriez être alerté sans avoir besoin d'être aussi parano que moi.</p>\n<h3 id=\"eviter-les-factures-inutiles\"><a class=\"header-anchor\" href=\"#eviter-les-factures-inutiles\" aria-hidden=\"true\">#</a> Éviter les factures inutiles</h3>\n<p>Avoir une infrastructure qui s'adapte automatiquement au trafic s'avère très pratique. Mais ça peut aussi être une source de surprises dans les factures. Attaque DDOS, erreur de programmation, ces événements peuvent parfois <a href=\"https://medium.com/@asankha/lambda-programming-errors-that-could-cost-you-thousands-of-dollars-a-day-265dfac354f\" target=\"_blank\" rel=\"noopener noreferrer\">coûter très cher<OutboundLink/></a>.</p>\n<p>Quelques petits conseils pour essayer d'éviter les problèmes :</p>\n<ul>\n<li>surveiller l'évolution du coût de votre lambda ;</li>\n<li>surveiller le nombre d'invocations de votre lambda ;</li>\n<li>garder à jour les moyens de contact (email notamment) de votre compte AWS, histoire de toujours recevoir toutes les alertes envoyées par Amazon ;</li>\n<li>mettre un cloudflare ou protection équivalente devant votre lambda ;</li>\n<li>limiter le nombre de lambdas qu'il est possible d'exécuter en parallèle ;</li>\n<li>supprimer la lambda lorsqu'elle n'est plus utile.</li>\n</ul>\n<h2 id=\"pour-conclure\"><a class=\"header-anchor\" href=\"#pour-conclure\" aria-hidden=\"true\">#</a> Pour conclure</h2>\n<p>J'espère vous avoir permis, si vous n'avez encore jamais eu l'occasion de toucher à du FaaS, de découvrir le cloud de manière un peu plus concrète et d'avoir une meilleure idée de son fonctionnement. J'espère également vous avoir montré à quel point il est devenu simple d'utiliser des lambdas en PHP, notamment grâce à Bref et sa documentation plus que complète. 🤓</p>\n<p>Enfin, je tiens à remercier Matthieu Napoli pour le super travail fourni, depuis un bon moment, pour démocratiser cette technologie, notamment au sein de la communauté PHP.</p>\n<p>Quelques sources utilisées pour cet article et des lectures pour aller plus loin :</p>\n<ul>\n<li><a href=\"https://bref.sh/docs/\" target=\"_blank\" rel=\"noopener noreferrer\">https://bref.sh/docs/<OutboundLink/></a></li>\n<li><a href=\"https://dashbird.io/blog/aws-lambda-pricing-model-explained/\" target=\"_blank\" rel=\"noopener noreferrer\">https://dashbird.io/blog/aws-lambda-pricing-model-explained/<OutboundLink/></a></li>\n<li><a href=\"https://www.xtivia.com/compare-faas-paas-saas/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.xtivia.com/compare-faas-paas-saas/<OutboundLink/></a></li>\n<li><a href=\"https://mnapoli.fr/serverless-php-faq/\" target=\"_blank\" rel=\"noopener noreferrer\">https://mnapoli.fr/serverless-php-faq/<OutboundLink/></a></li>\n<li><a href=\"https://kinsta.com/fr/blog/php-serverless/\" target=\"_blank\" rel=\"noopener noreferrer\">https://kinsta.com/fr/blog/php-serverless/<OutboundLink/></a></li>\n<li><a href=\"https://www.theodo.fr/digital-et-strategie/serverless-faas-une-revolution\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.theodo.fr/digital-et-strategie/serverless-faas-une-revolution<OutboundLink/></a></li>\n</ul>\n</div>\n",null]}