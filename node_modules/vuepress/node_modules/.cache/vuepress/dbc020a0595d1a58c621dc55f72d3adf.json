{"remainingRequest":"/Users/vivi./Dev/myVuePressDoc/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/vivi./Dev/myVuePressDoc/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/vivi./Dev/myVuePressDoc/docs/symfony/lesattributsphp8danssymfony.md?vue&type=template&id=1bb5926e&","dependencies":[{"path":"/Users/vivi./Dev/myVuePressDoc/docs/symfony/lesattributsphp8danssymfony.md","mtime":1632144881638},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/cache-loader/dist/cjs.js","mtime":1660115262090},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/cache-loader/dist/cjs.js","mtime":1660115262090},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/babel-loader/lib/index.js","mtime":1660115261629},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1660115262578},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/cache-loader/dist/cjs.js","mtime":1660115262090},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/vue-loader/lib/index.js","mtime":1660115262578},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1660115261540}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"les-attributs-php-8-dans-symfony\"><a class=\"header-anchor\" href=\"#les-attributs-php-8-dans-symfony\" aria-hidden=\"true\">#</a> Les attributs PHP 8 dans Symfony</h1>\n<p>Utilisation des attributs PHP 8 à la place des annotations.</p>\n<ol>\n<li>Les attributs PHP 8</li>\n<li>Annotation vs. Attributs</li>\n<li>Dans Symfony</li>\n<li>Les contraintes de validation</li>\n<li>Doctrine</li>\n<li>Conclusion</li>\n</ol>\n<h2 id=\"les-attributs-php-8\"><a class=\"header-anchor\" href=\"#les-attributs-php-8\" aria-hidden=\"true\">#</a> Les attributs PHP 8</h2>\n<hr>\n<p>Avec sa 8ème version, PHP a introduit une nouveauté assez attendue : <a href=\"https://www.php.net/manual/fr/language.attributes.overview.php\" target=\"_blank\" rel=\"noopener noreferrer\">les attributs<OutboundLink/></a>.</p>\n<p>Cette fonctionnalité permet de définir des métadonnées dans votre code. Ces méta données peuvent ensuite être lues grâce à l'<a href=\"https://www.php.net/manual/fr/book.reflection.php\" target=\"_blank\" rel=\"noopener noreferrer\">API de Reflection<OutboundLink/></a> de PHP.</p>\n<p>Concrêtement, <strong>les attributs répondent aux mêmes besoins et s'utilisent globalement de la même façon que les annotations</strong>, mais en natif.</p>\n<h2 id=\"annotation-vs-attributs\"><a class=\"header-anchor\" href=\"#annotation-vs-attributs\" aria-hidden=\"true\">#</a> Annotation vs. Attributs</h2>\n<hr>\n<p><strong>Quelles sont donc les différences entre les annotations et les attributs ?</strong></p>\n<p>Les annotations commencent par <code>@</code> et se place dans un docblock. <a href=\"https://www.doctrine-project.org/projects/doctrine-annotations/en/1.10/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Un parser écrit en PHP<OutboundLink/></a> lit ces annotations en parsant le fichier <code>.php</code> pour en extraire les méta données.</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>use App\\MetaData\\Foobar;\n\nclass Foo\n{\n  /**\n   * @Foobar\n   */\n  private string $foobar\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Les attributs ont une syntaxe un peu différente mais s'utilisent de la même façon au détail près qu'il s'agit d'une <strong>fonctionnalité native de PHP</strong>. Il n'y a donc pas besoin de parser tiers, les attributs sont interprétés par PHP en même temps que le reste du code.</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>use App\\MetaData\\Foobar;\n\nclass Foo\n{\n  #[Foobar]\n  private string $foobar\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"dans-symfony\"><a class=\"header-anchor\" href=\"#dans-symfony\" aria-hidden=\"true\">#</a> Dans Symfony</h2>\n<hr>\n<p>Dans un projet Symfony, il y a plusieurs endroits où vous pouvez avoir à écrire des annotations. Vous pouvez les utilisez pour <a href=\"https://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/routing.html\" target=\"_blank\" rel=\"noopener noreferrer\">déclarer une route<OutboundLink/></a>, pour configurer <a href=\"https://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html\" target=\"_blank\" rel=\"noopener noreferrer\">la conversion de paramètres<OutboundLink/></a>, pour décrire une <a href=\"https://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/security.html\" target=\"_blank\" rel=\"noopener noreferrer\">règle de sécurité<OutboundLink/></a> ou pour configurer <a href=\"https://symfony.com/doc/current/validation.html\" target=\"_blank\" rel=\"noopener noreferrer\">des contraintes de validations<OutboundLink/></a> par exemple. Si vous utilisez <a href=\"https://www.doctrine-project.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Doctrine<OutboundLink/></a> vous pouvez également les utiliser pour déclarer votre mapping d'ORM.</p>\n<p>Et bien il est désormais possible <strong>d'utiliser des attributs à la place des annotations</strong> pour faire tout cela, ou presque.</p>\n<p>De façon générale, dans Symfony, il est assez aisé de migrer des annotations vers les attributs car souvent <strong>les classes utilisées pour décrire les annotations sont les mêmes que pour les attributs</strong>.</p>\n<p>Certain outils comme <a href=\"https://getrector.org/blog/2020/11/30/smooth-upgrade-to-php-8-in-diffs#12-symfony-annotations-to-attributes\" target=\"_blank\" rel=\"noopener noreferrer\">Rector permettent de migrer automatiquement les annotations vers des attributs<OutboundLink/></a>.</p>\n<h2 id=\"dans-les-controleurs\"><a class=\"header-anchor\" href=\"#dans-les-controleurs\" aria-hidden=\"true\">#</a> Dans les contrôleurs</h2>\n<p>Dans les contrôleurs, globalement y a pas grand chose qui change, vous pouvez utiliser les annotations existantes en attributs avec quasiment la même syntaxe :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>use Symfony\\Component\\Routing\\Annotation\\Route;\n\nclass DefaultController extends AbstractController\n{\n  #[Route(&#39;/&#39;, methods: [&#39;GET&#39;], name: &quot;homepage&quot;)]\n  public function homepage()\n  {\n  }\n\n  #[Route(&#39;/foobar/{foo_id}/{bar_id}&#39;)]\n  #[ParamConverter(&#39;foo&#39;, options: [&#39;mapping&#39; =&gt; [&#39;foo_id&#39; =&gt; &#39;id&#39;]])]\n  #[ParamConverter(&#39;bar&#39;, options: [&#39;mapping&#39; =&gt; [&#39;bar_id&#39; =&gt; &#39;id&#39;]])]\n  public function foobar(Foo $foo, Bar $bar)\n  {\n  }\n\n  #[Route(&#39;/article/{article_slug}&#39;)]\n  #[Entity(&#39;article&#39;, expr: &#39;repository.findOneBySlug(article_slug)&#39;)]\n  public function article(Article $article)\n  {\n  }\n\n  #[IsGranted(&#39;ROLE_ADMIN&#39;)]\n  public function admin()\n  {\n  }\n\n  #[Security(&quot;is_granted(&#39;ROLE_ADMIN&#39;) and is_granted(&#39;ROLE_SUPER_ADMIN&#39;)&quot;)]\n  public function dashboard()\n  {\n  }\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Pour plus de détails, reportez vous aux différentes documentations qui intêgrent désormais, en plus des exemples d'anotations, leurs équivalents avec les attributs.</p>\n<p><img src=\"https://www.elao.com/images/posts/2021/php-attributes-symfony/symfony-attributes-doc.png\" alt=\"Les attributs PHP dans Symfony\" title=\"Les attributs PHP dans Symfony\"></p>\n<h2 id=\"les-contraintes-de-validation\"><a class=\"header-anchor\" href=\"#les-contraintes-de-validation\" aria-hidden=\"true\">#</a> Les contraintes de validation</h2>\n<hr>\n<p>Comme pour le reste des annotations fournies par Symfony, vous pouvez réutiliser la plupart des contraintes de validations en attributs :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>use Symfony\\Component\\Validator\\Constraints as Assert;\n\nclass Foobar\n{\n  #[Assert\\NotBlank]\n  #[Assert\\Type(&#39;string&#39;)]\n  #[Assert\\Length(min: 2, max: 40)]\n  private string $name;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Ça se gâte lorsque vous souhaitez utiliser des contraintes de validations imbriquées comme avec <a href=\"https://symfony.com/doc/current/reference/constraints/AtLeastOneOf.html\" target=\"_blank\" rel=\"noopener noreferrer\">AtLeastOneOf<OutboundLink/></a>, <a href=\"https://symfony.com/doc/current/reference/constraints/All.html\" target=\"_blank\" rel=\"noopener noreferrer\">All<OutboundLink/></a> ou <a href=\"https://symfony.com/doc/current/reference/constraints/Collection.html\" target=\"_blank\" rel=\"noopener noreferrer\">Collection<OutboundLink/></a> par exemple.</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>use Symfony\\Component\\Validator\\Constraints as Assert;\n\nclass Foobar\n{\n  /**\n   * @Assert\\All({\n   *   @Assert\\NotBlank,\n   *   @Assert\\Length(min=3)\n   * })\n   */\n  protected $things = [];\n\n  /**\n   * @Assert\\Collection(fields={\n   *   &quot;email&quot;={\n   *     @Assert\\NotBlank,\n   *     @Assert\\Email\n   *   },\n   *   &quot;description&quot;={\n   *     @Assert\\NotBlank,\n   *     @Assert\\Length(min=10, max=255, message=&quot;Lorem ipsum&quot;)\n   *   }\n   * })\n   */\n  protected $contact;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>En effet, <strong>les attributs PHP ne peuvent pas s'imbriquer</strong>, il n'est donc pas possible de reproduire cette configuration avec les attributs.</p>\n<p><a href=\"https://github.com/symfony/symfony/issues/38503\" target=\"_blank\" rel=\"noopener noreferrer\">Une issue est ouverte sur le GitHub de Symfony<OutboundLink/></a> sur ce sujet. La conclusion est qu'il faut <strong>attendre une évolution des attributs dans une prochaine version de PHP</strong> pour pouvoir instancier des objets dans les attributs et utiliser une syntaxe de ce style :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>use Symfony\\Component\\Validator\\Constraints as Assert;\n\nclass Foobar\n{\n  #[Assert\\Collection(fields: [\n    &#39;email&#39; =&gt; [\n      new Assert\\NotBlank,\n      new Assert\\Email,\n    ],\n    &#39;description&#39; =&gt; [\n      new Assert\\NotBlank,\n      new Assert\\Length(min: 10, max: 255, message: &quot;Lorem ipsum&quot;)\n    ]\n  ]]\n  protected $contact;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>En attendant, la solution la plus simple pour ce genre de cas est de créer une contrainte custom. Ceci a été rendu très simple depuis l'ajout de la contrainte <a href=\"https://symfony.com/doc/current/reference/constraints/Compound.html\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Compound</code><OutboundLink/></a>.</p>\n<p>En PHP, pas de limitation, vous pouvez imbriquer les contraintes comme vous le souhaitez :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>namespace App\\Validator\\Constraints;\n\nuse Symfony\\Component\\Validator\\Constraints as Assert\\Assert;\n\n#[\\Attribute(\\Attribute::TARGET_PROPERTY | \\Attribute::TARGET_METHOD | \\Attribute::IS_REPEATABLE)]\nclass Contact extends Compound\n{\n  protected function getConstraints(array $options): array\n  {\n    return [\n      new Assert\\Collection([\n        &#39;fields&#39; =&gt; [\n          &#39;email&#39; =&gt; [\n            new Assert\\NotBlank(),\n            new Assert\\Email(),\n          ],\n          &#39;description&#39; =&gt; [\n            new Assert\\NotBlank(),\n            new Assert\\Length([&#39;min&#39; =&gt; 10, &#39;max&#39; =&gt; 255, &#39;message&#39; =&gt; &quot;Lorem ipsum&quot;]),\n          ],\n        ],\n      ]),\n    ];\n  }\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Attention à bien configurer votre contrainte en tant qu'attribute <code>#[\\Attribute()]</code> et la bonne combinaison de constantes.</p>\n<p>Vous pouvez ensuite ajouter votre contrainte en tant qu'attribut :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>use App\\Validator\\Constraints;\n\nclass Foobar\n{\n  #[Constraints/Contact]\n  protected $contact;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Cette solution, bien que nécessitant de créer une classe, vous permet de regrouper vos contraintes dans un ensemble réutilisable. Si vous vous essayez au DDD c'est une solution intéressante car elle permet de lier un concept métier à ce groupe de contraintes.</p>\n<h2 id=\"doctrine\"><a class=\"header-anchor\" href=\"#doctrine\" aria-hidden=\"true\">#</a> Doctrine</h2>\n<hr>\n<p>Plus récemment est sortie <a href=\"https://www.doctrine-project.org/2021/05/24/orm2.9.html\" target=\"_blank\" rel=\"noopener noreferrer\">Doctrine 2.9<OutboundLink/></a> proposant le mapping via les attributs.</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>use Doctrine\\DBAL\\Types\\Types;\nuse Doctrine\\ORM\\Mapping AS ORM;\n\n#[ORM\\Entity(repositoryClass: PostRepository::class)]\nclass Foobar\n{\n  #[ORM\\Column(type: Types::INTEGER)]\n  #[ORM\\Id, ORM\\GeneratedValue(strategy: &#39;AUTO&#39;)]\n  private ?int $id;\n\n  #[ORM\\Column(type: Types::BOOLEAN)]\n  private bool $active = false;\n\n  #[ORM\\Column(type: Types::SIMPLE_ARRAY)]\n  private array $contents = [];\n\n  #[ORM\\ManyToOne(targetEntity: User::class)]\n  public $owner;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Comme Symfony, Doctrine réutilise les mêmes classes que pour leur annotations pour leur attributs.</p>\n<p>Doctrine fait également face à l'impossibilité d'imbriquer les attributs comme cela était fait avec les annotations <code>@JoinTable</code> ou <code>@JoinColumns</code> mais a résolu cela en créant de nouveaux attributs à placer au même niveau.</p>\n<p>Avec les annotations (imbriquées) :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class Post\n{\n  /**\n   * @ManyToMany(targetEntity=&quot;Tag&quot;)\n   * @JoinTable(name=&quot;post_tags&quot;,\n   *   joinColumns={\n   *     @JoinColumn(name=&quot;post_id&quot;, referencedColumnName=&quot;id&quot;)\n   *   },\n   *   inverseJoinColumns={\n   *     @JoinColumn(name=&quot;tag_id&quot;, referencedColumnName=&quot;id&quot;)\n   *   }\n   * )\n   */\n   public Collection $tags;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Avec les attributs (au même niveau) :</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class Post\n{\n  #[ORM\\ManyToMany(targetEntity: Tag::class)]\n  #[ORM\\JoinTable(name: &quot;post_tags&quot;)]\n  #[ORM\\JoinColumn(name: &quot;post_id&quot;, referencedColumnName: &quot;id&quot;)]\n  #[ORM\\InverseJoinColumn(name: &quot;tag_id&quot;, referencedColumnName: &quot;id&quot;)]\n  public Collection $tags;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"conclusion\"><a class=\"header-anchor\" href=\"#conclusion\" aria-hidden=\"true\">#</a> Conclusion</h2>\n<hr>\n<p>Les attributs offrent une nouvelle alternative aux annotations. Natifs, ils sont plus rapides et ne nécessitent pas de code tier pour être interprété.</p>\n</div>\n",null]}