{"remainingRequest":"/Users/vivi./Dev/myVuePressDoc/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/vivi./Dev/myVuePressDoc/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/vivi./Dev/myVuePressDoc/docs/symfony/votersetdroitsdacces.md?vue&type=template&id=bc95dab2&","dependencies":[{"path":"/Users/vivi./Dev/myVuePressDoc/docs/symfony/votersetdroitsdacces.md","mtime":1632144884506},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/cache-loader/dist/cjs.js","mtime":1660115262090},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/cache-loader/dist/cjs.js","mtime":1660115262090},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/babel-loader/lib/index.js","mtime":1660115261629},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1660115262578},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/cache-loader/dist/cjs.js","mtime":1660115262090},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/vue-loader/lib/index.js","mtime":1660115262578},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1660115261540}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"faciliter-la-gestion-des-droits-d-acces-avec-les-voters\"><a class=\"header-anchor\" href=\"#faciliter-la-gestion-des-droits-d-acces-avec-les-voters\" aria-hidden=\"true\">#</a> Faciliter la gestion des droits d'accès avec les Voters</h1>\n<p>===========================================================================================</p>\n<p>Dans beaucoup de projets où une gestion de droits d'accès est nécessaire, les rôles et contrôles d'accès définis dans le fichier « security.yml » peuvent être suffisants.<br>\nPar exemple, les administrateurs ont le rôle <code>ROLE_ADMIN</code>, et les utilisateurs ont le rôle <code>ROLE_USER</code>.</p>\n<p>Mais dès lors que l'on souhaite affiner un peu plus le contrôle des droits d'accès, ce système devient vite limité.</p>\n<p>Prenons l'exemple d'un site qui permet à ses membres enregistrés de publier des articles. Nous avons une entité « Article » qui a une relation vers notre entité User « author ».<br>\nLe comportement que l'on voudrait mettre en place fonctionnerait ainsi: chaque membre peut éditer ou supprimer ses propres articles, uniquement les siens, et les administrateurs ont, eux, accès à ces actions pour tous les articles.</p>\n<p>Nous ne pouvons pas vérifier le simple rôle <code>ROLE_USER</code> lors du contrôle d'accès, cela autoriserait tous les membres à éditer tous les articles.<br>\nUne solution serait vérifier le propriétaire de l'article dans toutes les actions concernées, mais cela place plus de logique dans les contrôleurs, et du code répété.</p>\n<p>Pour implémenter ce contrôle d'accès, nous allons plutôt utiliser le système de Voters de Symfony2. Nous allons utiliser deux nouveau rôles: <code>ROLE_ARTICLE_EDIT</code> pour le droit d'édition, et <code>ROLE_ARTICLE_DELETE</code> pour la suppression. Le seul code consacré au contrôle des droits dans nos actions devrait être un simple <code>isGranted</code>:</p>\n<pre><code>// dans l'action d'édition\nif (false === $securityContext-&gt;isGranted('ROLE_ARTICLE_EDIT', $article) {\n    throw new AccessDeniedHttpException();\n}\n\n// dans l'action de suppression\nif (false === $securityContext-&gt;isGranted('ROLE_ARTICLE_DELETE', $article) {\n    throw new AccessDeniedHttpException();\n}\n</code></pre>\n<p>Commençons par donner systèmatiquement ces droits aux administrateurs en éditant « security.yml »:</p>\n<pre><code>security:\n    role_hierarchy:\n        ROLE_ADMIN:\n            - ROLE_USER\n            [...]\n            - ROLE_ARTICLE_EDIT\n            - ROLE_ARTICLE_DELETE\n</code></pre>\n<p>Pour comprendre ce que nous allons maintenant faire, une première petite explication.<br>\nUn Voter est un service qui sera appelé par la couche de sécurité de Symfony au moment où l'on vérifiera des droits d'accès. A l'issue de son exécution, le Voter peut renvoyer une réponse parmis trois possibilités:</p>\n<ul>\n<li><code>ACCESS_GRANTED</code> s'il autorise l'accès,</li>\n<li><code>ACCESS_DENIED</code> s'il refuse l'accès,</li>\n<li>ou enfin <code>ACCESS_ABSTAIN</code> s'il reste neutre.</li>\n</ul>\n<p>La politique de sécurité par défaut (c'est configurable) de Symfony veut qu'un accès soit donné à un utilisateur si au moins un voteur renvoie <code>ACCESS_GRANTED</code>.</p>\n<p>Nous voulons donc que notre voteur renvoie <code>ACCESS_GRANTED</code> lorsque l'utilisateur connecté est bien l'auteur de l'article auquel il tente d'accèder, <code>ACCESS_DENIED</code> s'il n'en est pas l'auteur, et qu'il s'abstienne de voter avec <code>ACCESS_ABSTAIN</code> si les droits testés ne le concernent pas.</p>\n<p>Pour le cas des administrateurs, Symfony utilise en interne un <code>RoleHierarchyVoter</code> qui traite la hiérarchie de tous les rôles commençant par « <code>ROLE_</code> » dans la section <code>role_hierarchy</code> du « security.yml ». Dans notre cas, ce voter donnera donc automatiquement <code>ACCESS_GRANTED</code> pour nos deux rôles à tous les utilisateurs qui possèdent <code>ROLE_ADMIN</code>.</p>\n<p>Le code est assez simple:</p>\n<p>namespace MyProject\\Bundle\\MyBundle\\Security;</p>\n<p>use Symfony\\Component\\Security\\Core\\Authorization\\Voter\\VoterInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;</p>\n<p>class OwnerVoter implements VoterInterface\n{\n// Cette méthode permet de définir pour quels rôles le voteur doit être\n// appelé, nous définissons ici que ce voteur sera appelé seulement sur\n// les rôles qui commencent par 'ROLE_ARTICLE_'\npublic function supportsAttribute($attribute)\n{\nreturn 1 === preg_match('/^ROLE_ARTICLE_/', $attribute);\n}</p>\n<pre><code>// Cette méthode est utilisée pour vérifier la classe de l'utilisateur,\n// ce qui ne nous concerne pas dans notre exemple\npublic function supportsClass($class)\n{\n    return true;\n}\n\n// La méthode principale qui doit retourner le vote\npublic function vote(TokenInterface $token, $object, array $attributes)\n{\n    // Par défaut, nous n'intervenons pas dans la décision de vote\n    $vote = VoterInterface::ACCESS_ABSTAIN;\n\n    // Nous vérifions tous les rôles à tester...\n    foreach ($attributes as $attribute) {\n        // ... et nous ignorons ceux qui ne nous concernent pas\n        if (false === $this-&gt;supportsAttribute($attribute)) {\n            continue;\n        }\n\n        // pour les rôles qui nous concernent, nous enverrons par défaut\n        // un refus, à moins que l'utilisateur soit propriétaire de\n        // l'article\n        $user = $token-&gt;getUser();\n        $vote = VoterInterface::ACCESS_DENIED;\n\n        // $object est l'objet passé en paramètre lors de l'appel de\n        // &quot;isGranted&quot; dans notre action, c'est donc notre article\n        if ($object-&gt;getAuthor()-&gt;getId() === $user-&gt;getId()) {\n            $vote = VoterInterface::ACCESS_GRANTED;\n        }\n    }\n\n    return $vote;\n}\n</code></pre>\n<p>}</p>\n<p>C'est tout pour le code de notre voteur ! Il faut maintenant le déclarer dans nos services:</p>\n<pre><code>services:\n    owner_voter:\n        class: MyProject\\Bundle\\MyBundle\\Security\\OwnerVoter\n        public: false\n        tags:\n            - { name: security.voter }\n</code></pre>\n<p>Et voilà ! Nos actions restent propres, et nous avons une vérification automatique sur la propriété des articles qui sera très facile à réutiliser ailleurs dans notre projet.<br>\nPar exemple, si nous voulons ajouter un système de publication, nous voudrons qu'un article pas encore publié ne soit visible que par son auteur. Dans ce cas nous n'aurons qu'à créer par exemple un <code>ROLE_ARTICLE_PRIVATE_VIEW</code>, le donner à <code>ROLE_ADMIN</code> dans « security.yml », et notre voteur fera automatiquement la vérification pour les utilisateurs membres.</p>\n</div>\n",null]}