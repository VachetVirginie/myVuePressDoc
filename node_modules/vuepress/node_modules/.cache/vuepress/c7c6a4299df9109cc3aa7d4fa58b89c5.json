{"remainingRequest":"/Users/vivi./Dev/myVuePressDoc/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/vivi./Dev/myVuePressDoc/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/vivi./Dev/myVuePressDoc/docs/php/php8.md?vue&type=template&id=d12b8de0&","dependencies":[{"path":"/Users/vivi./Dev/myVuePressDoc/docs/php/php8.md","mtime":1636121298236},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/cache-loader/dist/cjs.js","mtime":1660115262090},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/cache-loader/dist/cjs.js","mtime":1660115262090},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/babel-loader/lib/index.js","mtime":1660115261629},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1660115262578},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/cache-loader/dist/cjs.js","mtime":1660115262090},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/vue-loader/lib/index.js","mtime":1660115262578},{"path":"/Users/vivi./Dev/myVuePressDoc/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1660115261540}],"contextDependencies":[],"result":["\n<div class=\"content\"><h3 id=\"changements-dans-les-casts-de-nombres\"><a class=\"header-anchor\" href=\"#changements-dans-les-casts-de-nombres\" aria-hidden=\"true\">#</a> Changements dans les casts de nombres[]</h3>\n<p>Commen√ßons ce tour des nouveaut√©s en douceur ![üòÉ] .</p>\n<p>Lorsque vous passez une cha√Æne de caract√®res en param√®tre d'une fonction qui attend un nombre, PHP tente de tout convertir en nombre. En PHP 7, si cette cha√Æne n'√©tait pas convertible, la fonction recevait 0.</p>\n<p>Avec PHP 8 si la cha√Æne de caract√®re est effectivement un nombre, elle est convertie, sinon vous obtiendrez une exception.</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function foo(int $i) {\n\n}\n\nfoo(&#39;2 et autre chose&#39;); // throw TypeError\nfoo(&#39;2&#39;); // fonctionne toujours si vous n&#39;avez pas sp√©cifi√© le strict types\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"les-unions-de-types\"><a class=\"header-anchor\" href=\"#les-unions-de-types\" aria-hidden=\"true\">#</a> Les unions de types[]</h3>\n<p>Clairement l'une des nouvelles fonctionnalit√©s qui me pla√Æt le plus‚ÄØ! Dans les derni√®res versions de PHP nous avons vu arriver le typage strict, mais lorsqu'on prend plusieurs types potentiels en param√®tres il nous faut toujours re-v√©rifier le type car on ne peut pas r√©clamer cela √† PHP. Dans cette nouvelle version de PHP on pourra donc faire des unions de type et s'√©viter cette t√¢che.</p>\n<p>Voici un exemple d'interface fonctionnant avec l'union de types‚ÄØ:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>interface ContainsNumberInterface\n{\n    public function setNumber(int|float $number);\n    public function getNumber(): int|float;\n}\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"le-type-mixed\"><a class=\"header-anchor\" href=\"#le-type-mixed\" aria-hidden=\"true\">#</a> Le type mixed[]</h3>\n<p>C'est un nouveau type qui vient s'ajouter aux types natifs existant dans PHP. Il a fait longtemps d√©bat car d'un c√¥t√© inutile, puisqu'il n'oblige √† rien lors de l'utilisation d'une fonction ou d'un attribut. Mais PHP 8 rajoute ce type. Voyez l√† l'obligation de tout typer explicitement <img src=\"https://zestedesavoir.com/static/smileys/svg/clin.svg\" alt=\";)\"> .</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class Something\n{\n    public mixed $userData;\n}\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Note: il a √©t√© d√©cid√© d'utiliser mixed et non pas <code>any</code> comme on peut voir dans d'autres langages car la communaut√© PHP enti√®re s'accorde √† utiliser ce wording pour sp√©cifier un &quot;multi-type&quot; en documentation.</p>\n<h3 id=\"les-expressions-match\"><a class=\"header-anchor\" href=\"#les-expressions-match\" aria-hidden=\"true\">#</a> Les expressions match[]</h3>\n<p>Plus rapide √† √©crire, mais aussi plus rapide √† ex√©cuter qu'un switch, les expressions match ressemblent tout de m√™me grandement √† un switch‚ÄØ:</p>\n<ul>\n<li>Elles retournent directement quelque chose</li>\n<li>Elles font une comparaison stricte contrairement au switch</li>\n</ul>\n<p>En voici un exemple illustratif‚ÄØ:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>// En utilisant un switch\nswitch(8.0) {\n  case &quot;8.0&quot;:\n    $result = &quot;Oh non !&quot;;\n    break;\n  case 8.0:\n    $result = &quot;Ce que j&#39;esp√®re&quot;;\n    break;\n}\necho $result; // Affiche &quot;Oh non !&quot;\n\necho match (8.0) {\n    &quot;8.0&quot; =&gt; &quot;Oh non !&quot;,\n    8.0 =&gt; &quot;Ce que j&#39;esp√®re&quot;,\n}; // Affiche &quot;Ce que j&#39;esp√®re&quot;\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"les-arguments-nommes\"><a class=\"header-anchor\" href=\"#les-arguments-nommes\" aria-hidden=\"true\">#</a> Les arguments nomm√©s[]</h3>\n<p>Certaines fonctions ont une longue liste d'arguments optionnels, et devoir sp√©cifier les arguments interm√©diaires n'est pas toujours utile ou peut m√™me porter √† confusion‚ÄØ! PHP 8 nous propose donc cette nouvelle fonctionnalit√©‚ÄØ: les arguments nomm√©s.</p>\n<p>Voici un exemple‚ÄØ:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>&lt;?php\n$items = [1, 2, &#39;foo&#39;];\narray_filter(array: $items, callback: function ($item) { return is_int($item); });\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"les-attributs\"><a class=\"header-anchor\" href=\"#les-attributs\" aria-hidden=\"true\">#</a> Les attributs[]</h3>\n<p>A partir de maintenant on s'accordera pour dire &quot;propri√©t√©&quot; de classe et &quot;attribut&quot; pour ce qui va suivre d'accord‚ÄØ? <img src=\"https://zestedesavoir.com/static/smileys/svg/clin.svg\" alt=\";)\"></p>\n<p>En PHP on a l'habitude d'avoir des commentaires contenant des annotations. Heureusement l'API de r√©flexion de PHP nous permet de simplifier le processus de parsing des annotations en commentaires... Mais √ßa n'√©tait pas assez au go√ªt g√©n√©ral, et √ßa fait d'ailleurs depuis PHP 5.4 (environ) que les discussions sont ouvertes au sujet de faire quelque chose de &quot;plus int√©gr√© √† PHP&quot;. (pour les annotations Symfony et la plupart des frameworks utilisent un package nomm√© <code>doctrine/annotations</code>)</p>\n<p>Nous y voici donc, on peut √† pr√©sent utiliser les <strong>attributs</strong> pour remplacer les annotations. Voyons comment on peut d√©clarer un attribut.</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>#[Attribute]\nclass Column\n{\n    public string $name;\n\n    public function __construct(string $name = null)\n    {\n        $this-&gt;name = $name;\n    }\n}\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Voici un exemple d'utilisation de notre attribut. (Bient√¥t nos entit√©s doctrine ressembleront √† cela !)</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>final class User\n{\n    #[ORM\\Id()]\n    #[ORM\\Column(&quot;id&quot;)]\n    private int $id;\n}\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Et pour finir on utilise l'API de r√©flexion de PHP:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$reflectionClass = new ReflectionClass(User::class);\n$attributes = $reflectionClass-&gt;getMethods()[0]-&gt;getAttributes(Column::class); // ‚ú®\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Note‚ÄØ: Les attributs doivent √™tre support√©es par votre librairie, PHP ne fera pas la conversion automatiquement entre annotation et attributs.</p>\n<h4 id=\"normes-valeurs-par-defaut\"><a class=\"header-anchor\" href=\"#normes-valeurs-par-defaut\" aria-hidden=\"true\">#</a> Normes valeurs par defaut:</h4>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th style=\"text-align:center\">Default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>string</td>\n<td style=\"text-align:center\">''</td>\n</tr>\n<tr>\n<td>dateTimeInterface</td>\n<td style=\"text-align:center\">null</td>\n</tr>\n<tr>\n<td>array</td>\n<td style=\"text-align:center\">[]</td>\n</tr>\n<tr>\n<td>int</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td>bool</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nouveautes-sur-le-throw\"><a class=\"header-anchor\" href=\"#nouveautes-sur-le-throw\" aria-hidden=\"true\">#</a> Nouveaut√©s sur le throw[]</h3>\n<p>Dans un premier temps, la clause throw est devenue une expression. C'est tout b√™te, mais √ßa permet par exemple de rendre le code suivant valide:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$value = $nullableValue ?? throw new InvalidArgumentException();\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Et une petite modification a √©t√© faite sur le catch: le nom de variable est maintenant optionnel si vous n'avez pas besoin de cette derni√®re.</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>try {\n    throw new TypeError();\n} catch (TypeError) {\n    echo &#39;oups erreur de type&#39;;\n}\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"l-operateur-¬´-null-safe-¬ª\"><a class=\"header-anchor\" href=\"#l-operateur-¬´-null-safe-¬ª\" aria-hidden=\"true\">#</a> L'op√©rateur ¬´‚ÄØNull Safe‚ÄØ¬ª[]</h3>\n<p>C'est l'une des fonctionnalit√©s qui m'attire le plus: elle permet de sortir de ce qu'on appelle commun√©ment le ¬´‚ÄØ<a href=\"https://afilina.com/null-hell\" target=\"_blank\" rel=\"noopener noreferrer\">null hell<OutboundLink/></a>‚ÄØ¬ª.</p>\n<p>Concr√®tement, vous allez pouvoir remplacer ce code:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$country =  null;\n\nif ($session !== null) {\n    $user = $session-&gt;user;\n\n    if ($user !== null) {\n        $address = $user-&gt;getAddress();\n\n        if ($address !== null) {\n            $country = $address-&gt;country;\n        }\n    }\n}\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Par celui-ci:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>$country = $session?-&gt;user?-&gt;getAddress()?-&gt;country;\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>N'oubliez cependant pas que moins vous aurez de <code>null</code>, mieux vous vous porterez psychologiquement‚ÄØ!</p>\n<h3 id=\"promotion-des-proprietes-du-constructeur\"><a class=\"header-anchor\" href=\"#promotion-des-proprietes-du-constructeur\" aria-hidden=\"true\">#</a> Promotion des propri√©t√©s du constructeur[]</h3>\n<p>Cette fonctionnalit√© est en r√©alit√© une nouvelle fa√ßon de d√©clarer les propri√©t√©s de classe: PHP nous permet de les d√©clarer directement dans le constructeur, cela dans le but d'√©viter le code redondant que l'on voit habituellement dans les classes.</p>\n<p>Voici un exemple avant la nouvelle fonctionnalit√©‚ÄØ:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class User\n{\n    private string $name;\n    private string $email;\n\n    public function __construct(string $name, string $email)\n    {\n        $this-&gt;name = $name;\n        $this-&gt;email = $email;\n    }\n}\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>Et apr√®s‚ÄØ:</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class User\n{\n    public function __construct(\n        private string $name,\n        private string $email\n    ) {}\n}\n\n</code></pre>\n<!--beforeend--></div><!--afterend--></div>\n",null]}